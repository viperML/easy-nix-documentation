import { exec as exec_cb } from "node:child_process";
import { promisify } from "node:util";
import { readFile } from "node:fs/promises";
import { createMarkdownRenderer, MarkdownRenderer, type SiteConfig } from "vitepress";

/**
 * A raw NixOS option generated by pkgs.nixosOptionsDoc.
 */
export interface RawNixosOption {
    description: string,
    declarations: string[],
    readOnly: boolean,
    type: string,
    loc: string[],
    default?: NixosValue,
    example?: NixosValue,
}

/**
 * A NixOS module option that has been rendered. Any of the fields
 * may be raw HTML.
 */
export interface RenderedNixosOption {
    description: string,
    declarations: string[],
    readOnly: boolean,
    type: string,
    loc: string[],
    default?: string | undefined,
    example?: string | undefined,
}

export type NixosValue = LiteralMD | LiteralExpression

export interface LiteralMD {
    _type: "literalMD",
    text: string,
}

export interface LiteralExpression {
    _type: "literalExpression",
    text: string,
}

function renderValue(value: NixosValue, md: MarkdownRenderer): string {
    if (value._type === "literalMD") {
        return md.render(`~~~plaintext
${value.text}
~~~`)
    } else if (value._type == "literalExpression") {
        return  md.render(`~~~nix
${value.text}
~~~`)
    } else {
        console.log("Unknown Value")
        console.log(value)
        return value;
    }
}




export interface LoaderConfig {
    /**
     * Only include options that match the following regex in the output object.
     * Note that this is unnecessary, as RenderDocs can filter options too.
     */
    include?: RegExp[],
    /**
     * Change the path where options are declared. May be used to strip the /nix/store
     * prefix, and link into your documentation.
     *
     * Example:
     *
     * mapDeclarations: declaration => {
     *     const relDecl = stripNixStore(declaration);
     *     return `<a href="http://github.com/NixOS/nixpkgs/tree/nixos-unstable/${relDecl}">&lt;${relDecl}&gt;</a>`;
     * },
     *
     * @param location - The original declaration location.
     * @returns The mapped declaration.
     */
    mapDeclarations?: (location: string) => string,
}

/**
 * Removes the /nix/store/<hash>-foo/ components from a store path, and returns
 * from the fourth component to the end.
 */
export function stripNixStore(storePath: string): string {
    return storePath.replace(/^\/nix\/store\/[^/]+-[^/]+\//, "");
}

/**
 * Load NixOS module options into an object compatible with RenderDocs
 *
 * @param installable Same as with Nix, either a flake, and absolute nix store path or -f + argument
 */
export async function loadOptions(installable: string, loaderConfig?: LoaderConfig): Promise<Record<string, RenderedNixosOption>> {
    const config = globalThis.VITEPRESS_CONFIG as SiteConfig
    const md = await createMarkdownRenderer(config.srcDir, config.markdown, config.site.base, config.logger)

    const exec = promisify(exec_cb);
    const storePath = await (async () => {
        // User passes just a pre-built derivation
        if (installable.startsWith("/nix/store")) {
            return installable;
        } else {
            const { stdout } = await exec(`nix build ${installable} --no-link --print-out-paths`);
            return stdout.trim();
        }
    })();

    const file = `${storePath}/share/doc/nixos/options.json`

    const data = await readFile(file, { encoding: "utf-8" });

    const obj: Record<string, RawNixosOption> = JSON.parse(data);

    const res = Object.fromEntries(
        Object.entries(obj)
            .filter(([name]) => loaderConfig?.include?.some(include => include.test(name)) ?? true)
            .map(([name, value]) => {
                let description = md.render(value.description);
                // Simply drop these
                description = description.replace("{file}", "");
                description = description.replace("{command}", "");

                const res: RenderedNixosOption = {
                    description,
                    default: value.default && renderValue(value.default, md),
                    example: value.example && renderValue(value.example, md),
                    declarations: value.declarations.map(declaration => {
                        if (loaderConfig?.mapDeclarations !== undefined) {
                            return loaderConfig.mapDeclarations(declaration);
                        }
                        return `<code>${declaration}</code>`;
                    }),
                    readOnly: value.readOnly,
                    type: md.render(`
~~~plaintext
${value.type}
~~~
`),
                    loc: value.loc,
                }
                return [name, res];
            })
    );

    return res;
}
